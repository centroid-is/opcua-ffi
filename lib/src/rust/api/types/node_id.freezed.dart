// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'node_id.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WrapIdentifier {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) numeric,
    required TResult Function(WrapUaString field0) string,
    required TResult Function(WrapGuid field0) guid,
    required TResult Function(WrapByteString field0) byteString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? numeric,
    TResult? Function(WrapUaString field0)? string,
    TResult? Function(WrapGuid field0)? guid,
    TResult? Function(WrapByteString field0)? byteString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? numeric,
    TResult Function(WrapUaString field0)? string,
    TResult Function(WrapGuid field0)? guid,
    TResult Function(WrapByteString field0)? byteString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WrapIdentifier_Numeric value) numeric,
    required TResult Function(WrapIdentifier_String value) string,
    required TResult Function(WrapIdentifier_Guid value) guid,
    required TResult Function(WrapIdentifier_ByteString value) byteString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WrapIdentifier_Numeric value)? numeric,
    TResult? Function(WrapIdentifier_String value)? string,
    TResult? Function(WrapIdentifier_Guid value)? guid,
    TResult? Function(WrapIdentifier_ByteString value)? byteString,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WrapIdentifier_Numeric value)? numeric,
    TResult Function(WrapIdentifier_String value)? string,
    TResult Function(WrapIdentifier_Guid value)? guid,
    TResult Function(WrapIdentifier_ByteString value)? byteString,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WrapIdentifierCopyWith<$Res> {
  factory $WrapIdentifierCopyWith(
          WrapIdentifier value, $Res Function(WrapIdentifier) then) =
      _$WrapIdentifierCopyWithImpl<$Res, WrapIdentifier>;
}

/// @nodoc
class _$WrapIdentifierCopyWithImpl<$Res, $Val extends WrapIdentifier>
    implements $WrapIdentifierCopyWith<$Res> {
  _$WrapIdentifierCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$WrapIdentifier_NumericImplCopyWith<$Res> {
  factory _$$WrapIdentifier_NumericImplCopyWith(
          _$WrapIdentifier_NumericImpl value,
          $Res Function(_$WrapIdentifier_NumericImpl) then) =
      __$$WrapIdentifier_NumericImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$WrapIdentifier_NumericImplCopyWithImpl<$Res>
    extends _$WrapIdentifierCopyWithImpl<$Res, _$WrapIdentifier_NumericImpl>
    implements _$$WrapIdentifier_NumericImplCopyWith<$Res> {
  __$$WrapIdentifier_NumericImplCopyWithImpl(
      _$WrapIdentifier_NumericImpl _value,
      $Res Function(_$WrapIdentifier_NumericImpl) _then)
      : super(_value, _then);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WrapIdentifier_NumericImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WrapIdentifier_NumericImpl extends WrapIdentifier_Numeric {
  const _$WrapIdentifier_NumericImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'WrapIdentifier.numeric(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrapIdentifier_NumericImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WrapIdentifier_NumericImplCopyWith<_$WrapIdentifier_NumericImpl>
      get copyWith => __$$WrapIdentifier_NumericImplCopyWithImpl<
          _$WrapIdentifier_NumericImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) numeric,
    required TResult Function(WrapUaString field0) string,
    required TResult Function(WrapGuid field0) guid,
    required TResult Function(WrapByteString field0) byteString,
  }) {
    return numeric(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? numeric,
    TResult? Function(WrapUaString field0)? string,
    TResult? Function(WrapGuid field0)? guid,
    TResult? Function(WrapByteString field0)? byteString,
  }) {
    return numeric?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? numeric,
    TResult Function(WrapUaString field0)? string,
    TResult Function(WrapGuid field0)? guid,
    TResult Function(WrapByteString field0)? byteString,
    required TResult orElse(),
  }) {
    if (numeric != null) {
      return numeric(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WrapIdentifier_Numeric value) numeric,
    required TResult Function(WrapIdentifier_String value) string,
    required TResult Function(WrapIdentifier_Guid value) guid,
    required TResult Function(WrapIdentifier_ByteString value) byteString,
  }) {
    return numeric(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WrapIdentifier_Numeric value)? numeric,
    TResult? Function(WrapIdentifier_String value)? string,
    TResult? Function(WrapIdentifier_Guid value)? guid,
    TResult? Function(WrapIdentifier_ByteString value)? byteString,
  }) {
    return numeric?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WrapIdentifier_Numeric value)? numeric,
    TResult Function(WrapIdentifier_String value)? string,
    TResult Function(WrapIdentifier_Guid value)? guid,
    TResult Function(WrapIdentifier_ByteString value)? byteString,
    required TResult orElse(),
  }) {
    if (numeric != null) {
      return numeric(this);
    }
    return orElse();
  }
}

abstract class WrapIdentifier_Numeric extends WrapIdentifier {
  const factory WrapIdentifier_Numeric(final int field0) =
      _$WrapIdentifier_NumericImpl;
  const WrapIdentifier_Numeric._() : super._();

  @override
  int get field0;

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WrapIdentifier_NumericImplCopyWith<_$WrapIdentifier_NumericImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WrapIdentifier_StringImplCopyWith<$Res> {
  factory _$$WrapIdentifier_StringImplCopyWith(
          _$WrapIdentifier_StringImpl value,
          $Res Function(_$WrapIdentifier_StringImpl) then) =
      __$$WrapIdentifier_StringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WrapUaString field0});
}

/// @nodoc
class __$$WrapIdentifier_StringImplCopyWithImpl<$Res>
    extends _$WrapIdentifierCopyWithImpl<$Res, _$WrapIdentifier_StringImpl>
    implements _$$WrapIdentifier_StringImplCopyWith<$Res> {
  __$$WrapIdentifier_StringImplCopyWithImpl(_$WrapIdentifier_StringImpl _value,
      $Res Function(_$WrapIdentifier_StringImpl) _then)
      : super(_value, _then);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WrapIdentifier_StringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WrapUaString,
    ));
  }
}

/// @nodoc

class _$WrapIdentifier_StringImpl extends WrapIdentifier_String {
  const _$WrapIdentifier_StringImpl(this.field0) : super._();

  @override
  final WrapUaString field0;

  @override
  String toString() {
    return 'WrapIdentifier.string(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrapIdentifier_StringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WrapIdentifier_StringImplCopyWith<_$WrapIdentifier_StringImpl>
      get copyWith => __$$WrapIdentifier_StringImplCopyWithImpl<
          _$WrapIdentifier_StringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) numeric,
    required TResult Function(WrapUaString field0) string,
    required TResult Function(WrapGuid field0) guid,
    required TResult Function(WrapByteString field0) byteString,
  }) {
    return string(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? numeric,
    TResult? Function(WrapUaString field0)? string,
    TResult? Function(WrapGuid field0)? guid,
    TResult? Function(WrapByteString field0)? byteString,
  }) {
    return string?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? numeric,
    TResult Function(WrapUaString field0)? string,
    TResult Function(WrapGuid field0)? guid,
    TResult Function(WrapByteString field0)? byteString,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WrapIdentifier_Numeric value) numeric,
    required TResult Function(WrapIdentifier_String value) string,
    required TResult Function(WrapIdentifier_Guid value) guid,
    required TResult Function(WrapIdentifier_ByteString value) byteString,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WrapIdentifier_Numeric value)? numeric,
    TResult? Function(WrapIdentifier_String value)? string,
    TResult? Function(WrapIdentifier_Guid value)? guid,
    TResult? Function(WrapIdentifier_ByteString value)? byteString,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WrapIdentifier_Numeric value)? numeric,
    TResult Function(WrapIdentifier_String value)? string,
    TResult Function(WrapIdentifier_Guid value)? guid,
    TResult Function(WrapIdentifier_ByteString value)? byteString,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class WrapIdentifier_String extends WrapIdentifier {
  const factory WrapIdentifier_String(final WrapUaString field0) =
      _$WrapIdentifier_StringImpl;
  const WrapIdentifier_String._() : super._();

  @override
  WrapUaString get field0;

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WrapIdentifier_StringImplCopyWith<_$WrapIdentifier_StringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WrapIdentifier_GuidImplCopyWith<$Res> {
  factory _$$WrapIdentifier_GuidImplCopyWith(_$WrapIdentifier_GuidImpl value,
          $Res Function(_$WrapIdentifier_GuidImpl) then) =
      __$$WrapIdentifier_GuidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WrapGuid field0});
}

/// @nodoc
class __$$WrapIdentifier_GuidImplCopyWithImpl<$Res>
    extends _$WrapIdentifierCopyWithImpl<$Res, _$WrapIdentifier_GuidImpl>
    implements _$$WrapIdentifier_GuidImplCopyWith<$Res> {
  __$$WrapIdentifier_GuidImplCopyWithImpl(_$WrapIdentifier_GuidImpl _value,
      $Res Function(_$WrapIdentifier_GuidImpl) _then)
      : super(_value, _then);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WrapIdentifier_GuidImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WrapGuid,
    ));
  }
}

/// @nodoc

class _$WrapIdentifier_GuidImpl extends WrapIdentifier_Guid {
  const _$WrapIdentifier_GuidImpl(this.field0) : super._();

  @override
  final WrapGuid field0;

  @override
  String toString() {
    return 'WrapIdentifier.guid(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrapIdentifier_GuidImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WrapIdentifier_GuidImplCopyWith<_$WrapIdentifier_GuidImpl> get copyWith =>
      __$$WrapIdentifier_GuidImplCopyWithImpl<_$WrapIdentifier_GuidImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) numeric,
    required TResult Function(WrapUaString field0) string,
    required TResult Function(WrapGuid field0) guid,
    required TResult Function(WrapByteString field0) byteString,
  }) {
    return guid(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? numeric,
    TResult? Function(WrapUaString field0)? string,
    TResult? Function(WrapGuid field0)? guid,
    TResult? Function(WrapByteString field0)? byteString,
  }) {
    return guid?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? numeric,
    TResult Function(WrapUaString field0)? string,
    TResult Function(WrapGuid field0)? guid,
    TResult Function(WrapByteString field0)? byteString,
    required TResult orElse(),
  }) {
    if (guid != null) {
      return guid(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WrapIdentifier_Numeric value) numeric,
    required TResult Function(WrapIdentifier_String value) string,
    required TResult Function(WrapIdentifier_Guid value) guid,
    required TResult Function(WrapIdentifier_ByteString value) byteString,
  }) {
    return guid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WrapIdentifier_Numeric value)? numeric,
    TResult? Function(WrapIdentifier_String value)? string,
    TResult? Function(WrapIdentifier_Guid value)? guid,
    TResult? Function(WrapIdentifier_ByteString value)? byteString,
  }) {
    return guid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WrapIdentifier_Numeric value)? numeric,
    TResult Function(WrapIdentifier_String value)? string,
    TResult Function(WrapIdentifier_Guid value)? guid,
    TResult Function(WrapIdentifier_ByteString value)? byteString,
    required TResult orElse(),
  }) {
    if (guid != null) {
      return guid(this);
    }
    return orElse();
  }
}

abstract class WrapIdentifier_Guid extends WrapIdentifier {
  const factory WrapIdentifier_Guid(final WrapGuid field0) =
      _$WrapIdentifier_GuidImpl;
  const WrapIdentifier_Guid._() : super._();

  @override
  WrapGuid get field0;

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WrapIdentifier_GuidImplCopyWith<_$WrapIdentifier_GuidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WrapIdentifier_ByteStringImplCopyWith<$Res> {
  factory _$$WrapIdentifier_ByteStringImplCopyWith(
          _$WrapIdentifier_ByteStringImpl value,
          $Res Function(_$WrapIdentifier_ByteStringImpl) then) =
      __$$WrapIdentifier_ByteStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WrapByteString field0});
}

/// @nodoc
class __$$WrapIdentifier_ByteStringImplCopyWithImpl<$Res>
    extends _$WrapIdentifierCopyWithImpl<$Res, _$WrapIdentifier_ByteStringImpl>
    implements _$$WrapIdentifier_ByteStringImplCopyWith<$Res> {
  __$$WrapIdentifier_ByteStringImplCopyWithImpl(
      _$WrapIdentifier_ByteStringImpl _value,
      $Res Function(_$WrapIdentifier_ByteStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WrapIdentifier_ByteStringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WrapByteString,
    ));
  }
}

/// @nodoc

class _$WrapIdentifier_ByteStringImpl extends WrapIdentifier_ByteString {
  const _$WrapIdentifier_ByteStringImpl(this.field0) : super._();

  @override
  final WrapByteString field0;

  @override
  String toString() {
    return 'WrapIdentifier.byteString(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WrapIdentifier_ByteStringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WrapIdentifier_ByteStringImplCopyWith<_$WrapIdentifier_ByteStringImpl>
      get copyWith => __$$WrapIdentifier_ByteStringImplCopyWithImpl<
          _$WrapIdentifier_ByteStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) numeric,
    required TResult Function(WrapUaString field0) string,
    required TResult Function(WrapGuid field0) guid,
    required TResult Function(WrapByteString field0) byteString,
  }) {
    return byteString(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? numeric,
    TResult? Function(WrapUaString field0)? string,
    TResult? Function(WrapGuid field0)? guid,
    TResult? Function(WrapByteString field0)? byteString,
  }) {
    return byteString?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? numeric,
    TResult Function(WrapUaString field0)? string,
    TResult Function(WrapGuid field0)? guid,
    TResult Function(WrapByteString field0)? byteString,
    required TResult orElse(),
  }) {
    if (byteString != null) {
      return byteString(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WrapIdentifier_Numeric value) numeric,
    required TResult Function(WrapIdentifier_String value) string,
    required TResult Function(WrapIdentifier_Guid value) guid,
    required TResult Function(WrapIdentifier_ByteString value) byteString,
  }) {
    return byteString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WrapIdentifier_Numeric value)? numeric,
    TResult? Function(WrapIdentifier_String value)? string,
    TResult? Function(WrapIdentifier_Guid value)? guid,
    TResult? Function(WrapIdentifier_ByteString value)? byteString,
  }) {
    return byteString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WrapIdentifier_Numeric value)? numeric,
    TResult Function(WrapIdentifier_String value)? string,
    TResult Function(WrapIdentifier_Guid value)? guid,
    TResult Function(WrapIdentifier_ByteString value)? byteString,
    required TResult orElse(),
  }) {
    if (byteString != null) {
      return byteString(this);
    }
    return orElse();
  }
}

abstract class WrapIdentifier_ByteString extends WrapIdentifier {
  const factory WrapIdentifier_ByteString(final WrapByteString field0) =
      _$WrapIdentifier_ByteStringImpl;
  const WrapIdentifier_ByteString._() : super._();

  @override
  WrapByteString get field0;

  /// Create a copy of WrapIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WrapIdentifier_ByteStringImplCopyWith<_$WrapIdentifier_ByteStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}
