// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'variant.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Variant {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VariantCopyWith<$Res> {
  factory $VariantCopyWith(Variant value, $Res Function(Variant) then) =
      _$VariantCopyWithImpl<$Res, Variant>;
}

/// @nodoc
class _$VariantCopyWithImpl<$Res, $Val extends Variant>
    implements $VariantCopyWith<$Res> {
  _$VariantCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$Variant_EmptyImplCopyWith<$Res> {
  factory _$$Variant_EmptyImplCopyWith(
          _$Variant_EmptyImpl value, $Res Function(_$Variant_EmptyImpl) then) =
      __$$Variant_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Variant_EmptyImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_EmptyImpl>
    implements _$$Variant_EmptyImplCopyWith<$Res> {
  __$$Variant_EmptyImplCopyWithImpl(
      _$Variant_EmptyImpl _value, $Res Function(_$Variant_EmptyImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Variant_EmptyImpl extends Variant_Empty {
  const _$Variant_EmptyImpl() : super._();

  @override
  String toString() {
    return 'Variant.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Variant_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Variant_Empty extends Variant {
  const factory Variant_Empty() = _$Variant_EmptyImpl;
  const Variant_Empty._() : super._();
}

/// @nodoc
abstract class _$$Variant_BooleanImplCopyWith<$Res> {
  factory _$$Variant_BooleanImplCopyWith(_$Variant_BooleanImpl value,
          $Res Function(_$Variant_BooleanImpl) then) =
      __$$Variant_BooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$Variant_BooleanImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_BooleanImpl>
    implements _$$Variant_BooleanImplCopyWith<$Res> {
  __$$Variant_BooleanImplCopyWithImpl(
      _$Variant_BooleanImpl _value, $Res Function(_$Variant_BooleanImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_BooleanImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Variant_BooleanImpl extends Variant_Boolean {
  const _$Variant_BooleanImpl(this.field0) : super._();

  @override
  final bool field0;

  @override
  String toString() {
    return 'Variant.boolean(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_BooleanImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_BooleanImplCopyWith<_$Variant_BooleanImpl> get copyWith =>
      __$$Variant_BooleanImplCopyWithImpl<_$Variant_BooleanImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return boolean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return boolean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class Variant_Boolean extends Variant {
  const factory Variant_Boolean(final bool field0) = _$Variant_BooleanImpl;
  const Variant_Boolean._() : super._();

  bool get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_BooleanImplCopyWith<_$Variant_BooleanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_SByteImplCopyWith<$Res> {
  factory _$$Variant_SByteImplCopyWith(
          _$Variant_SByteImpl value, $Res Function(_$Variant_SByteImpl) then) =
      __$$Variant_SByteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_SByteImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_SByteImpl>
    implements _$$Variant_SByteImplCopyWith<$Res> {
  __$$Variant_SByteImplCopyWithImpl(
      _$Variant_SByteImpl _value, $Res Function(_$Variant_SByteImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_SByteImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_SByteImpl extends Variant_SByte {
  const _$Variant_SByteImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.sByte(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_SByteImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_SByteImplCopyWith<_$Variant_SByteImpl> get copyWith =>
      __$$Variant_SByteImplCopyWithImpl<_$Variant_SByteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return sByte(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return sByte?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (sByte != null) {
      return sByte(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return sByte(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return sByte?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (sByte != null) {
      return sByte(this);
    }
    return orElse();
  }
}

abstract class Variant_SByte extends Variant {
  const factory Variant_SByte(final int field0) = _$Variant_SByteImpl;
  const Variant_SByte._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_SByteImplCopyWith<_$Variant_SByteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_ByteImplCopyWith<$Res> {
  factory _$$Variant_ByteImplCopyWith(
          _$Variant_ByteImpl value, $Res Function(_$Variant_ByteImpl) then) =
      __$$Variant_ByteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_ByteImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_ByteImpl>
    implements _$$Variant_ByteImplCopyWith<$Res> {
  __$$Variant_ByteImplCopyWithImpl(
      _$Variant_ByteImpl _value, $Res Function(_$Variant_ByteImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_ByteImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_ByteImpl extends Variant_Byte {
  const _$Variant_ByteImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.byte(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_ByteImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_ByteImplCopyWith<_$Variant_ByteImpl> get copyWith =>
      __$$Variant_ByteImplCopyWithImpl<_$Variant_ByteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return byte(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return byte?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (byte != null) {
      return byte(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return byte(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return byte?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (byte != null) {
      return byte(this);
    }
    return orElse();
  }
}

abstract class Variant_Byte extends Variant {
  const factory Variant_Byte(final int field0) = _$Variant_ByteImpl;
  const Variant_Byte._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_ByteImplCopyWith<_$Variant_ByteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_Int16ImplCopyWith<$Res> {
  factory _$$Variant_Int16ImplCopyWith(
          _$Variant_Int16Impl value, $Res Function(_$Variant_Int16Impl) then) =
      __$$Variant_Int16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_Int16ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_Int16Impl>
    implements _$$Variant_Int16ImplCopyWith<$Res> {
  __$$Variant_Int16ImplCopyWithImpl(
      _$Variant_Int16Impl _value, $Res Function(_$Variant_Int16Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_Int16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_Int16Impl extends Variant_Int16 {
  const _$Variant_Int16Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.int16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_Int16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_Int16ImplCopyWith<_$Variant_Int16Impl> get copyWith =>
      __$$Variant_Int16ImplCopyWithImpl<_$Variant_Int16Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return int16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return int16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class Variant_Int16 extends Variant {
  const factory Variant_Int16(final int field0) = _$Variant_Int16Impl;
  const Variant_Int16._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_Int16ImplCopyWith<_$Variant_Int16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_UInt16ImplCopyWith<$Res> {
  factory _$$Variant_UInt16ImplCopyWith(_$Variant_UInt16Impl value,
          $Res Function(_$Variant_UInt16Impl) then) =
      __$$Variant_UInt16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_UInt16ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_UInt16Impl>
    implements _$$Variant_UInt16ImplCopyWith<$Res> {
  __$$Variant_UInt16ImplCopyWithImpl(
      _$Variant_UInt16Impl _value, $Res Function(_$Variant_UInt16Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_UInt16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_UInt16Impl extends Variant_UInt16 {
  const _$Variant_UInt16Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.uInt16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_UInt16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_UInt16ImplCopyWith<_$Variant_UInt16Impl> get copyWith =>
      __$$Variant_UInt16ImplCopyWithImpl<_$Variant_UInt16Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return uInt16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return uInt16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class Variant_UInt16 extends Variant {
  const factory Variant_UInt16(final int field0) = _$Variant_UInt16Impl;
  const Variant_UInt16._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_UInt16ImplCopyWith<_$Variant_UInt16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_Int32ImplCopyWith<$Res> {
  factory _$$Variant_Int32ImplCopyWith(
          _$Variant_Int32Impl value, $Res Function(_$Variant_Int32Impl) then) =
      __$$Variant_Int32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_Int32ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_Int32Impl>
    implements _$$Variant_Int32ImplCopyWith<$Res> {
  __$$Variant_Int32ImplCopyWithImpl(
      _$Variant_Int32Impl _value, $Res Function(_$Variant_Int32Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_Int32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_Int32Impl extends Variant_Int32 {
  const _$Variant_Int32Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.int32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_Int32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_Int32ImplCopyWith<_$Variant_Int32Impl> get copyWith =>
      __$$Variant_Int32ImplCopyWithImpl<_$Variant_Int32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return int32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return int32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class Variant_Int32 extends Variant {
  const factory Variant_Int32(final int field0) = _$Variant_Int32Impl;
  const Variant_Int32._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_Int32ImplCopyWith<_$Variant_Int32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_UInt32ImplCopyWith<$Res> {
  factory _$$Variant_UInt32ImplCopyWith(_$Variant_UInt32Impl value,
          $Res Function(_$Variant_UInt32Impl) then) =
      __$$Variant_UInt32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_UInt32ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_UInt32Impl>
    implements _$$Variant_UInt32ImplCopyWith<$Res> {
  __$$Variant_UInt32ImplCopyWithImpl(
      _$Variant_UInt32Impl _value, $Res Function(_$Variant_UInt32Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_UInt32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_UInt32Impl extends Variant_UInt32 {
  const _$Variant_UInt32Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.uInt32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_UInt32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_UInt32ImplCopyWith<_$Variant_UInt32Impl> get copyWith =>
      __$$Variant_UInt32ImplCopyWithImpl<_$Variant_UInt32Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return uInt32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return uInt32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class Variant_UInt32 extends Variant {
  const factory Variant_UInt32(final int field0) = _$Variant_UInt32Impl;
  const Variant_UInt32._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_UInt32ImplCopyWith<_$Variant_UInt32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_Int64ImplCopyWith<$Res> {
  factory _$$Variant_Int64ImplCopyWith(
          _$Variant_Int64Impl value, $Res Function(_$Variant_Int64Impl) then) =
      __$$Variant_Int64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Variant_Int64ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_Int64Impl>
    implements _$$Variant_Int64ImplCopyWith<$Res> {
  __$$Variant_Int64ImplCopyWithImpl(
      _$Variant_Int64Impl _value, $Res Function(_$Variant_Int64Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_Int64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Variant_Int64Impl extends Variant_Int64 {
  const _$Variant_Int64Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'Variant.int64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_Int64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_Int64ImplCopyWith<_$Variant_Int64Impl> get copyWith =>
      __$$Variant_Int64ImplCopyWithImpl<_$Variant_Int64Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return int64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return int64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class Variant_Int64 extends Variant {
  const factory Variant_Int64(final int field0) = _$Variant_Int64Impl;
  const Variant_Int64._() : super._();

  int get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_Int64ImplCopyWith<_$Variant_Int64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_UInt64ImplCopyWith<$Res> {
  factory _$$Variant_UInt64ImplCopyWith(_$Variant_UInt64Impl value,
          $Res Function(_$Variant_UInt64Impl) then) =
      __$$Variant_UInt64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$Variant_UInt64ImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_UInt64Impl>
    implements _$$Variant_UInt64ImplCopyWith<$Res> {
  __$$Variant_UInt64ImplCopyWithImpl(
      _$Variant_UInt64Impl _value, $Res Function(_$Variant_UInt64Impl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_UInt64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$Variant_UInt64Impl extends Variant_UInt64 {
  const _$Variant_UInt64Impl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'Variant.uInt64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_UInt64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_UInt64ImplCopyWith<_$Variant_UInt64Impl> get copyWith =>
      __$$Variant_UInt64ImplCopyWithImpl<_$Variant_UInt64Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return uInt64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return uInt64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class Variant_UInt64 extends Variant {
  const factory Variant_UInt64(final BigInt field0) = _$Variant_UInt64Impl;
  const Variant_UInt64._() : super._();

  BigInt get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_UInt64ImplCopyWith<_$Variant_UInt64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_FloatImplCopyWith<$Res> {
  factory _$$Variant_FloatImplCopyWith(
          _$Variant_FloatImpl value, $Res Function(_$Variant_FloatImpl) then) =
      __$$Variant_FloatImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$Variant_FloatImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_FloatImpl>
    implements _$$Variant_FloatImplCopyWith<$Res> {
  __$$Variant_FloatImplCopyWithImpl(
      _$Variant_FloatImpl _value, $Res Function(_$Variant_FloatImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_FloatImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$Variant_FloatImpl extends Variant_Float {
  const _$Variant_FloatImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'Variant.float(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_FloatImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_FloatImplCopyWith<_$Variant_FloatImpl> get copyWith =>
      __$$Variant_FloatImplCopyWithImpl<_$Variant_FloatImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return float(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return float?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return float(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return float?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(this);
    }
    return orElse();
  }
}

abstract class Variant_Float extends Variant {
  const factory Variant_Float(final double field0) = _$Variant_FloatImpl;
  const Variant_Float._() : super._();

  double get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_FloatImplCopyWith<_$Variant_FloatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_DoubleImplCopyWith<$Res> {
  factory _$$Variant_DoubleImplCopyWith(_$Variant_DoubleImpl value,
          $Res Function(_$Variant_DoubleImpl) then) =
      __$$Variant_DoubleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$Variant_DoubleImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_DoubleImpl>
    implements _$$Variant_DoubleImplCopyWith<$Res> {
  __$$Variant_DoubleImplCopyWithImpl(
      _$Variant_DoubleImpl _value, $Res Function(_$Variant_DoubleImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_DoubleImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$Variant_DoubleImpl extends Variant_Double {
  const _$Variant_DoubleImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'Variant.double(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_DoubleImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_DoubleImplCopyWith<_$Variant_DoubleImpl> get copyWith =>
      __$$Variant_DoubleImplCopyWithImpl<_$Variant_DoubleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return double(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return double?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return double(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return double?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(this);
    }
    return orElse();
  }
}

abstract class Variant_Double extends Variant {
  const factory Variant_Double(final double field0) = _$Variant_DoubleImpl;
  const Variant_Double._() : super._();

  double get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_DoubleImplCopyWith<_$Variant_DoubleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_StringImplCopyWith<$Res> {
  factory _$$Variant_StringImplCopyWith(_$Variant_StringImpl value,
          $Res Function(_$Variant_StringImpl) then) =
      __$$Variant_StringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UaString field0});
}

/// @nodoc
class __$$Variant_StringImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_StringImpl>
    implements _$$Variant_StringImplCopyWith<$Res> {
  __$$Variant_StringImplCopyWithImpl(
      _$Variant_StringImpl _value, $Res Function(_$Variant_StringImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_StringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as UaString,
    ));
  }
}

/// @nodoc

class _$Variant_StringImpl extends Variant_String {
  const _$Variant_StringImpl(this.field0) : super._();

  @override
  final UaString field0;

  @override
  String toString() {
    return 'Variant.string(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_StringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_StringImplCopyWith<_$Variant_StringImpl> get copyWith =>
      __$$Variant_StringImplCopyWithImpl<_$Variant_StringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return string(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return string?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class Variant_String extends Variant {
  const factory Variant_String(final UaString field0) = _$Variant_StringImpl;
  const Variant_String._() : super._();

  UaString get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_StringImplCopyWith<_$Variant_StringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_DateTimeImplCopyWith<$Res> {
  factory _$$Variant_DateTimeImplCopyWith(_$Variant_DateTimeImpl value,
          $Res Function(_$Variant_DateTimeImpl) then) =
      __$$Variant_DateTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BoxUaDateTime field0});
}

/// @nodoc
class __$$Variant_DateTimeImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_DateTimeImpl>
    implements _$$Variant_DateTimeImplCopyWith<$Res> {
  __$$Variant_DateTimeImplCopyWithImpl(_$Variant_DateTimeImpl _value,
      $Res Function(_$Variant_DateTimeImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_DateTimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BoxUaDateTime,
    ));
  }
}

/// @nodoc

class _$Variant_DateTimeImpl extends Variant_DateTime {
  const _$Variant_DateTimeImpl(this.field0) : super._();

  @override
  final BoxUaDateTime field0;

  @override
  String toString() {
    return 'Variant.dateTime(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_DateTimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_DateTimeImplCopyWith<_$Variant_DateTimeImpl> get copyWith =>
      __$$Variant_DateTimeImplCopyWithImpl<_$Variant_DateTimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return dateTime(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return dateTime?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class Variant_DateTime extends Variant {
  const factory Variant_DateTime(final BoxUaDateTime field0) =
      _$Variant_DateTimeImpl;
  const Variant_DateTime._() : super._();

  BoxUaDateTime get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_DateTimeImplCopyWith<_$Variant_DateTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_GuidImplCopyWith<$Res> {
  factory _$$Variant_GuidImplCopyWith(
          _$Variant_GuidImpl value, $Res Function(_$Variant_GuidImpl) then) =
      __$$Variant_GuidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BoxUaGuid field0});
}

/// @nodoc
class __$$Variant_GuidImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_GuidImpl>
    implements _$$Variant_GuidImplCopyWith<$Res> {
  __$$Variant_GuidImplCopyWithImpl(
      _$Variant_GuidImpl _value, $Res Function(_$Variant_GuidImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_GuidImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BoxUaGuid,
    ));
  }
}

/// @nodoc

class _$Variant_GuidImpl extends Variant_Guid {
  const _$Variant_GuidImpl(this.field0) : super._();

  @override
  final BoxUaGuid field0;

  @override
  String toString() {
    return 'Variant.guid(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_GuidImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_GuidImplCopyWith<_$Variant_GuidImpl> get copyWith =>
      __$$Variant_GuidImplCopyWithImpl<_$Variant_GuidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return guid(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return guid?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (guid != null) {
      return guid(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return guid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return guid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (guid != null) {
      return guid(this);
    }
    return orElse();
  }
}

abstract class Variant_Guid extends Variant {
  const factory Variant_Guid(final BoxUaGuid field0) = _$Variant_GuidImpl;
  const Variant_Guid._() : super._();

  BoxUaGuid get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_GuidImplCopyWith<_$Variant_GuidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_StatusCodeImplCopyWith<$Res> {
  factory _$$Variant_StatusCodeImplCopyWith(_$Variant_StatusCodeImpl value,
          $Res Function(_$Variant_StatusCodeImpl) then) =
      __$$Variant_StatusCodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({StatusCode field0});
}

/// @nodoc
class __$$Variant_StatusCodeImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_StatusCodeImpl>
    implements _$$Variant_StatusCodeImplCopyWith<$Res> {
  __$$Variant_StatusCodeImplCopyWithImpl(_$Variant_StatusCodeImpl _value,
      $Res Function(_$Variant_StatusCodeImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_StatusCodeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as StatusCode,
    ));
  }
}

/// @nodoc

class _$Variant_StatusCodeImpl extends Variant_StatusCode {
  const _$Variant_StatusCodeImpl(this.field0) : super._();

  @override
  final StatusCode field0;

  @override
  String toString() {
    return 'Variant.statusCode(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_StatusCodeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_StatusCodeImplCopyWith<_$Variant_StatusCodeImpl> get copyWith =>
      __$$Variant_StatusCodeImplCopyWithImpl<_$Variant_StatusCodeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return statusCode(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return statusCode?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (statusCode != null) {
      return statusCode(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return statusCode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return statusCode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (statusCode != null) {
      return statusCode(this);
    }
    return orElse();
  }
}

abstract class Variant_StatusCode extends Variant {
  const factory Variant_StatusCode(final StatusCode field0) =
      _$Variant_StatusCodeImpl;
  const Variant_StatusCode._() : super._();

  StatusCode get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_StatusCodeImplCopyWith<_$Variant_StatusCodeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_ByteStringImplCopyWith<$Res> {
  factory _$$Variant_ByteStringImplCopyWith(_$Variant_ByteStringImpl value,
          $Res Function(_$Variant_ByteStringImpl) then) =
      __$$Variant_ByteStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ByteString field0});
}

/// @nodoc
class __$$Variant_ByteStringImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_ByteStringImpl>
    implements _$$Variant_ByteStringImplCopyWith<$Res> {
  __$$Variant_ByteStringImplCopyWithImpl(_$Variant_ByteStringImpl _value,
      $Res Function(_$Variant_ByteStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_ByteStringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as ByteString,
    ));
  }
}

/// @nodoc

class _$Variant_ByteStringImpl extends Variant_ByteString {
  const _$Variant_ByteStringImpl(this.field0) : super._();

  @override
  final ByteString field0;

  @override
  String toString() {
    return 'Variant.byteString(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_ByteStringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_ByteStringImplCopyWith<_$Variant_ByteStringImpl> get copyWith =>
      __$$Variant_ByteStringImplCopyWithImpl<_$Variant_ByteStringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return byteString(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return byteString?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (byteString != null) {
      return byteString(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return byteString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return byteString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (byteString != null) {
      return byteString(this);
    }
    return orElse();
  }
}

abstract class Variant_ByteString extends Variant {
  const factory Variant_ByteString(final ByteString field0) =
      _$Variant_ByteStringImpl;
  const Variant_ByteString._() : super._();

  ByteString get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_ByteStringImplCopyWith<_$Variant_ByteStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Variant_XmlElementImplCopyWith<$Res> {
  factory _$$Variant_XmlElementImplCopyWith(_$Variant_XmlElementImpl value,
          $Res Function(_$Variant_XmlElementImpl) then) =
      __$$Variant_XmlElementImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UaString field0});
}

/// @nodoc
class __$$Variant_XmlElementImplCopyWithImpl<$Res>
    extends _$VariantCopyWithImpl<$Res, _$Variant_XmlElementImpl>
    implements _$$Variant_XmlElementImplCopyWith<$Res> {
  __$$Variant_XmlElementImplCopyWithImpl(_$Variant_XmlElementImpl _value,
      $Res Function(_$Variant_XmlElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Variant_XmlElementImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as UaString,
    ));
  }
}

/// @nodoc

class _$Variant_XmlElementImpl extends Variant_XmlElement {
  const _$Variant_XmlElementImpl(this.field0) : super._();

  @override
  final UaString field0;

  @override
  String toString() {
    return 'Variant.xmlElement(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Variant_XmlElementImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Variant_XmlElementImplCopyWith<_$Variant_XmlElementImpl> get copyWith =>
      __$$Variant_XmlElementImplCopyWithImpl<_$Variant_XmlElementImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(bool field0) boolean,
    required TResult Function(int field0) sByte,
    required TResult Function(int field0) byte,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) int64,
    required TResult Function(BigInt field0) uInt64,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(UaString field0) string,
    required TResult Function(BoxUaDateTime field0) dateTime,
    required TResult Function(BoxUaGuid field0) guid,
    required TResult Function(StatusCode field0) statusCode,
    required TResult Function(ByteString field0) byteString,
    required TResult Function(UaString field0) xmlElement,
  }) {
    return xmlElement(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(bool field0)? boolean,
    TResult? Function(int field0)? sByte,
    TResult? Function(int field0)? byte,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? int64,
    TResult? Function(BigInt field0)? uInt64,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(UaString field0)? string,
    TResult? Function(BoxUaDateTime field0)? dateTime,
    TResult? Function(BoxUaGuid field0)? guid,
    TResult? Function(StatusCode field0)? statusCode,
    TResult? Function(ByteString field0)? byteString,
    TResult? Function(UaString field0)? xmlElement,
  }) {
    return xmlElement?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(bool field0)? boolean,
    TResult Function(int field0)? sByte,
    TResult Function(int field0)? byte,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? int64,
    TResult Function(BigInt field0)? uInt64,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(UaString field0)? string,
    TResult Function(BoxUaDateTime field0)? dateTime,
    TResult Function(BoxUaGuid field0)? guid,
    TResult Function(StatusCode field0)? statusCode,
    TResult Function(ByteString field0)? byteString,
    TResult Function(UaString field0)? xmlElement,
    required TResult orElse(),
  }) {
    if (xmlElement != null) {
      return xmlElement(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Variant_Empty value) empty,
    required TResult Function(Variant_Boolean value) boolean,
    required TResult Function(Variant_SByte value) sByte,
    required TResult Function(Variant_Byte value) byte,
    required TResult Function(Variant_Int16 value) int16,
    required TResult Function(Variant_UInt16 value) uInt16,
    required TResult Function(Variant_Int32 value) int32,
    required TResult Function(Variant_UInt32 value) uInt32,
    required TResult Function(Variant_Int64 value) int64,
    required TResult Function(Variant_UInt64 value) uInt64,
    required TResult Function(Variant_Float value) float,
    required TResult Function(Variant_Double value) double,
    required TResult Function(Variant_String value) string,
    required TResult Function(Variant_DateTime value) dateTime,
    required TResult Function(Variant_Guid value) guid,
    required TResult Function(Variant_StatusCode value) statusCode,
    required TResult Function(Variant_ByteString value) byteString,
    required TResult Function(Variant_XmlElement value) xmlElement,
  }) {
    return xmlElement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Variant_Empty value)? empty,
    TResult? Function(Variant_Boolean value)? boolean,
    TResult? Function(Variant_SByte value)? sByte,
    TResult? Function(Variant_Byte value)? byte,
    TResult? Function(Variant_Int16 value)? int16,
    TResult? Function(Variant_UInt16 value)? uInt16,
    TResult? Function(Variant_Int32 value)? int32,
    TResult? Function(Variant_UInt32 value)? uInt32,
    TResult? Function(Variant_Int64 value)? int64,
    TResult? Function(Variant_UInt64 value)? uInt64,
    TResult? Function(Variant_Float value)? float,
    TResult? Function(Variant_Double value)? double,
    TResult? Function(Variant_String value)? string,
    TResult? Function(Variant_DateTime value)? dateTime,
    TResult? Function(Variant_Guid value)? guid,
    TResult? Function(Variant_StatusCode value)? statusCode,
    TResult? Function(Variant_ByteString value)? byteString,
    TResult? Function(Variant_XmlElement value)? xmlElement,
  }) {
    return xmlElement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Variant_Empty value)? empty,
    TResult Function(Variant_Boolean value)? boolean,
    TResult Function(Variant_SByte value)? sByte,
    TResult Function(Variant_Byte value)? byte,
    TResult Function(Variant_Int16 value)? int16,
    TResult Function(Variant_UInt16 value)? uInt16,
    TResult Function(Variant_Int32 value)? int32,
    TResult Function(Variant_UInt32 value)? uInt32,
    TResult Function(Variant_Int64 value)? int64,
    TResult Function(Variant_UInt64 value)? uInt64,
    TResult Function(Variant_Float value)? float,
    TResult Function(Variant_Double value)? double,
    TResult Function(Variant_String value)? string,
    TResult Function(Variant_DateTime value)? dateTime,
    TResult Function(Variant_Guid value)? guid,
    TResult Function(Variant_StatusCode value)? statusCode,
    TResult Function(Variant_ByteString value)? byteString,
    TResult Function(Variant_XmlElement value)? xmlElement,
    required TResult orElse(),
  }) {
    if (xmlElement != null) {
      return xmlElement(this);
    }
    return orElse();
  }
}

abstract class Variant_XmlElement extends Variant {
  const factory Variant_XmlElement(final UaString field0) =
      _$Variant_XmlElementImpl;
  const Variant_XmlElement._() : super._();

  UaString get field0;

  /// Create a copy of Variant
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Variant_XmlElementImplCopyWith<_$Variant_XmlElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
