// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.5.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'byte_string.dart';
import 'guid.dart';
import 'monitored_item_create_request.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'string.dart';
part 'node_id.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `into`, `into`

Future<void> wrapidentifier({required WrapIdentifier a}) =>
    RustLib.instance.api.crateApiTypesNodeIdWrapidentifier(a: a);

Future<void> wrapnodeid({required WrapNodeId a}) =>
    RustLib.instance.api.crateApiTypesNodeIdWrapnodeid(a: a);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WrapNodeId>>
abstract class WrapNodeId implements RustOpaqueInterface {
  /// Test if the node id us a byte string
  bool isByteString();

  /// Test if the node id is a guid
  bool isGuid();

  /// Test if the node id is null, i.e. 0 namespace and 0 identifier
  bool isNull();

  /// Test if the node id is numeric
  bool isNumeric();

  /// Test if the node id is a string
  bool isString();

  factory WrapNodeId({required int namespace, required WrapIdentifier value}) =>
      RustLib.instance.api
          .crateApiTypesNodeIdWrapNodeIdNew(namespace: namespace, value: value);

  static WrapNodeId nextNumeric({required int namespace}) =>
      RustLib.instance.api
          .crateApiTypesNodeIdWrapNodeIdNextNumeric(namespace: namespace);

  /// Returns a null node id
  static WrapNodeId null_() =>
      RustLib.instance.api.crateApiTypesNodeIdWrapNodeIdNull();

  /// Returns the node id for the objects folder.
  static WrapNodeId objectsFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdWrapNodeIdObjectsFolderId();

  /// Returns the node id for the root folder.
  static WrapNodeId rootFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdWrapNodeIdRootFolderId();

  WrapMonitoredItemCreateRequest toMonitoredItemCreateRequest();

  /// Returns the node id for the types folder.
  static WrapNodeId typesFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdWrapNodeIdTypesFolderId();

  /// Returns the node id for the views folder.
  static WrapNodeId viewsFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdWrapNodeIdViewsFolderId();
}

@freezed
sealed class WrapIdentifier with _$WrapIdentifier {
  const WrapIdentifier._();

  const factory WrapIdentifier.numeric(
    int field0,
  ) = WrapIdentifier_Numeric;
  const factory WrapIdentifier.string(
    WrapUaString field0,
  ) = WrapIdentifier_String;
  const factory WrapIdentifier.guid(
    WrapGuid field0,
  ) = WrapIdentifier_Guid;
  const factory WrapIdentifier.byteString(
    WrapByteString field0,
  ) = WrapIdentifier_ByteString;

  static WrapIdentifier from(int v) =>
      RustLib.instance.api.crateApiTypesNodeIdWrapIdentifierFrom(v: v);
}
