// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'byte_string.dart';
import 'guid.dart';
import 'monitored_item_create_request.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'string.dart';
part 'node_id.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `into`, `into`

Future<void> wrapidentifier({required Identifier a}) =>
    RustLib.instance.api.crateApiTypesNodeIdWrapidentifier(a: a);

Future<void> wrapnodeid({required NodeId a}) =>
    RustLib.instance.api.crateApiTypesNodeIdWrapnodeid(a: a);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NodeId>>
abstract class NodeId implements RustOpaqueInterface {
  /// Test if the node id us a byte string
  bool isByteString();

  /// Test if the node id is a guid
  bool isGuid();

  /// Test if the node id is null, i.e. 0 namespace and 0 identifier
  bool isNull();

  /// Test if the node id is numeric
  bool isNumeric();

  /// Test if the node id is a string
  bool isString();

  factory NodeId({required int namespace, required Identifier value}) =>
      RustLib.instance.api
          .crateApiTypesNodeIdNodeIdNew(namespace: namespace, value: value);

  static NodeId nextNumeric({required int namespace}) => RustLib.instance.api
      .crateApiTypesNodeIdNodeIdNextNumeric(namespace: namespace);

  /// Returns a null node id
  static NodeId null_() => RustLib.instance.api.crateApiTypesNodeIdNodeIdNull();

  /// Returns the node id for the objects folder.
  static NodeId objectsFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdNodeIdObjectsFolderId();

  /// Returns the node id for the root folder.
  static NodeId rootFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdNodeIdRootFolderId();

  MonitoredItemCreateRequest toMonitoredItemCreateRequest();

  /// Returns the node id for the types folder.
  static NodeId typesFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdNodeIdTypesFolderId();

  /// Returns the node id for the views folder.
  static NodeId viewsFolderId() =>
      RustLib.instance.api.crateApiTypesNodeIdNodeIdViewsFolderId();
}

@freezed
sealed class Identifier with _$Identifier {
  const Identifier._();

  const factory Identifier.numeric(
    int field0,
  ) = Identifier_Numeric;
  const factory Identifier.string(
    UaString field0,
  ) = Identifier_String;
  const factory Identifier.guid(
    UaGuid field0,
  ) = Identifier_Guid;
  const factory Identifier.byteString(
    ByteString field0,
  ) = Identifier_ByteString;

  static Identifier from(int v) =>
      RustLib.instance.api.crateApiTypesNodeIdIdentifierFrom(v: v);
}
